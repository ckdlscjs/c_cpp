#include "PS_Lights.hlsli"

Texture2D Texture : register(t0); //psset으로세팅하였다
sampler TextureSampler : register(s0); //세팅하지않아도 기본샘플러가 레지스터0에 세팅된다

struct PS_INPUT
{
    float4 pos0 : SV_POSITION;
    float4 tex0 : TEXCOORD0;
    float4 normal0 : NORMAL0;
    float4 pos1 : WORLDP0;
};

cbuffer CB_Campos : register(b5)
{
    float4 campos;
};

float4 psmain(PS_INPUT input) : SV_Target
{
    float4 M = Texture.Sample(TextureSampler, input.tex0.xy); //텍스쳐값
    float4 P = input.pos1; //변환된 월드의정점
    clip(M.a - 0.5f);
    
    //DirectionalLight
    float3 L = normalize(-ld_dir); //광원을향하는벡터
    float3 N = normalize(input.normal0.xyz); //정점법선벡터 정규화
    float3 R = reflect(ld_dir, N); //반사벡터(입사벡터, 법선을 인자로사용)
    float3 V = normalize(campos.xyz - P.xyz); //시점을향하는벡터
    return float4(M.r, M.g, M.b, 0.7f); //DirectionalLight(L, N, R, V) * M; //마지막에 텍스쳐컬러를 곱해도 분배법칙에의해 같은결과가 나온다
    
    
    ////PointLight
    //float3 L = lp_pos - P.xyz; //점광, 정점에서 광원을향하는방향
    //float D = length(L);
    //if (D > lp_range)                                           //빛의 범위보다 멀리있을경우
    //    return float4(0.0f, 0.0f, 0.0f, 0.0f);
    //L /= D; //정규화
    //float3 N = normalize(input.normal0.xyz);
    //float3 R = reflect(-L, N); //빛의 입사벡터(-L)
    //float3 V = normalize(campos.xyz - P.xyz);
    //return PointLight(L, D, N, R, V) * M;
    
    
    ////SpotLight
    //float3 L = ls_pos - P.xyz;
    //float D = length(L);
    //if (D > ls_range)
    //    return float4(0.0f, 0.0f, 0.0f, 0.0f);
    //L /= D;
    //float3 N = normalize(input.normal0.xyz);
    //float3 R = reflect(-L, N);
    //float3 V = normalize(campos.xyz - P.xyz);
    //return SpotLight(L, D, N, R, V) * M;
}